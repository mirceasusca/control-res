%% 2D SISO DT system
clear; clc; close all;

Ts = 0.1;

% A, B controllable
A = [1.2,0.4;
    -0.3,0.9];
B = [1;0.5];
C = [1,1];
D = 0;

n = size(A,1);
m = size(B,2); 
p = size(C,1);

sys = ss(A,B,C,D,Ts);
pole(sys)
zero(sys)
% figure,step(sys,10)

%% LQI design
Q = diag([10,2,20])/10;
R = 0.5;
N = zeros(n+p,m);
[Klqi,S,e] = lqi(sys,Q,R,N);
K = -Klqi;
lqrStruct = struct('Q',Q,'R',R,'N',N,'K',K);

%% Closed-loop system (ideal)
Kx = K(1:n);
Kz = K(n+1:end);

Acl = [A+B*Kx,B*Kz;
    -Ts*C,eye(p)];
Bcl_ref = [zeros(n,m);Ts*eye(m)];
Ccl = [C,zeros(p)];
Dcl = zeros(p);

syscl = ss(Acl,Bcl_ref,Ccl,Dcl,Ts);
figure,step(syscl)

%%
tfin = 60;
% ref = @(t) 0.2;
r_eq = 0.2;
ref_sig = @(t) r_eq;
% ref = @(t) t>=2;

eqStructBlank = struct;

% %% Example to fetch equilibrium
% x_tilde_0 = [1,0,0];
qStructIdeal = struct(...
    'qU',@(x)qIdeal(x),...
    'qX',@(x)qIdeal(x),...
    'qY',@(x)qIdeal(x)...
    );
% eqStruct = struct;  % initial gol, doar sa faca simularea

%% Monte Carlo dataset creation for Kmeans clustering
% Nexp = 1000;
Nexp = 200;

% domeniul de variatie al conditiilor initiale
x0min = [-2,-2];
x0max = [2,2];

Xdataset = [];
Ydataset = [];
Udataset = [];

for k = 1:Nexp
    k
    x10 = x0min(1)+(x0max(1)-x0min(1))*rand(1);
    x20 = x0min(2)+(x0max(2)-x0min(2))*rand(1);
    x_tilde_0 = [x10;x20;0];
    info = sim_lqi(sys,lqrStruct,x_tilde_0,tfin,ref_sig,qStructIdeal,eqStructBlank);
    Xdataset = [Xdataset; info.XK'];
    Ydataset = [Ydataset; info.YK'];
    Udataset = [Udataset; info.UK'];
    % info.J  % just for print, not significant here
end

%% Precision and Kmeans optimization
range_x1 = [min(Xdataset(:,1)),max(Xdataset(:,1))];
range_x2 = [min(Xdataset(:,2)),max(Xdataset(:,2))];
range_y1  = [min(Ydataset(:,1)),max(Ydataset(:,1))];
range_u1  = [min(Udataset(:,1)),max(Udataset(:,1))];

n_bits = 7;
num_clusters_KX1 = 2^n_bits;
num_clusters_KX2 = 2^n_bits;
num_clusters_KY1 = 2^n_bits;
num_clusters_KU1 = 2^n_bits;

qUnif_x1 = diff(range_x1)/2^n_bits;  % profit de intregul domeniu parcurs
qUnif_x2 = diff(range_x2)/2^n_bits;
qUnif_y1 = diff(range_y1)/2^n_bits;
qUnif_u1 = diff(range_u1)/2^n_bits;

opts = statset('MaxIter', 500, 'Display', 'final');

%%
[~, CX1] = kmeans(Xdataset(:,1), num_clusters_KX1, 'Replicates', 7, 'Options', opts);

%%
[~, CX2] = kmeans(Xdataset(:,2), num_clusters_KX2, 'Replicates', 7, 'Options', opts);

%%
[~, CY1] = kmeans(Ydataset(:,1), num_clusters_KY1, 'Replicates', 7, 'Options', opts);

%%
[~, CU1] = kmeans(Udataset(:,1), num_clusters_KU1, 'Replicates', 7, 'Options', opts);

%%
CX1 = sort(CX1); 
CX2 = sort(CX2);
CY1 = sort(CY1);
CU1 = sort(CU1);

%% learned kmeans grid X
figure(Name="Kmeans X grid")
subplot(211)
stem(CX1,ones(size(CX1))),
ylabel('x1 grid')
subplot(212)
stem(CX2,ones(size(CX2)))
ylabel('x2 grid')

%% learned kmeans grid Y
figure(Name="Kmeans Y grid")
stem(CY1,ones(size(CY1))),

%% learned kmeans grid U
figure(Name="Kmeans U grid")
stem(CU1,ones(size(CU1))),


%% uniform quantizer X grid
figure(Name="Uniform X grid")
subplot(211)
stem([range_x1(1):qUnif_x1:range_x1(2)],ones(size([range_x1(1):qUnif_x1:range_x1(2)]))),
ylabel('x1 grid')
subplot(212)
stem([range_x2(1):qUnif_x2:range_x2(2)],ones(size([range_x2(1):qUnif_x2:range_x2(2)]))),
ylabel('x2 grid')

%% uniform quantizer Y grid
figure(Name="Uniform Y grid")
stem([range_y1(1):qUnif_y1:range_y1(2)],ones(size([range_y1(1):qUnif_y1:range_y1(2)]))),

%% uniform quantizer U grid
figure(Name="Uniform U grid")
stem([range_u1(1):qUnif_u1:range_u1(2)],ones(size([range_u1(1):qUnif_u1:range_u1(2)]))),

%%
% testat mai riguros pe mai multe stari initiale (si eventual referinte, 
% ca sa vedem cat de tare se degradeaza cuantizorul nostru fata de ce a 
% fost invatat -- robustete), nu doar schimbat manual

% establish new setup and deduce equilibrium
ref_sig_new = ref_sig;
% x_tilde_0 = [-0.5;0.75;0]; % trei stari initiale, (x1,x2,z1=0), z0=0 la integratoare, de obicei
x_tilde_0 = [+0.5;0.5;0]; 
% tfin = 2e5;
% tfin = 5e5;
% tfin = 1e6;

eqStruct = compute_forced_static_eq(A,B,C,Kx,Kz,r_eq);

% domeniul de variatie al conditiilor initiale
x0min = [-2,-2];
x0max = [2,2];
z0min = [-0.5];
z0max = [0.5];

Nsim = 20;

J_exp_mat = zeros(Nsim,3);

for k = 1:Nsim
    k
    x10 = x0min(1)+(x0max(1)-x0min(1))*rand(1);
    x20 = x0min(2)+(x0max(2)-x0min(2))*rand(1);
    z10 = z0min(1)+(z0max(1)-z0min(1))*rand(1);
    % x_tilde_0 = [x10;x20;0];
    x_tilde_0 = [x10;x20;z10];
    
    info_ideal = sim_lqi(sys,lqrStruct,x_tilde_0,tfin,ref_sig,qStructIdeal,eqStruct);
    
    % qStructKmeans = struct(...
    %     'qU',@(x)qCentroid1D(x,CU1),...
    %     'qX',@(x)qCentroid2D(x,CX1,CX2),...
    %     'qY',@(x)qCentroid1D(x,CY1)...
    %     );
    qStructKmeans = struct(...
        'qU',@(x)qIdeal(x),...
        'qX',@(x)qCentroid2D(x,CX1,CX2),...
        'qY',@(x)qIdeal(x)...
        );
    info_kmeans = sim_lqi(sys,lqrStruct,x_tilde_0,tfin,ref_sig,qStructKmeans,eqStruct);
    
    % qStructUniform = struct(...
    %     'qU',@(x)qIdeal(x),...
    %     'qX',@(x)qUniform2D(x,qUnif_x1,qUnif_x2),...
    %     'qY',@(x)qUniform(x,qUnif_y1)...
    %     );
    % qStructUniform = struct(...
    %     'qU',@(x)qUniform(x,qUnif_u1),...
    %     'qX',@(x)qUniform2D(x,qUnif_x1,qUnif_x2),...
    %     'qY',@(x)qUniform(x,qUnif_y1)...
    %     );
    qStructUniform = struct(...
        'qU',@(x)qIdeal(x),...
        'qX',@(x)qUniform2D(x,qUnif_x1,qUnif_x2),...
        'qY',@(x)qIdeal(x)...
        );
    info_uniform = sim_lqi(sys,lqrStruct,x_tilde_0,tfin,ref_sig,qStructUniform,eqStruct);

    J_experiments = [
        info_ideal.J;
        info_kmeans.J;
        info_uniform.J
    ];

    J_exp_mat(k,:) = J_experiments';
    (J_experiments(3)-J_experiments(1))/(J_experiments(2)-J_experiments(1))

end

%%
out = (J_exp_mat(:,3)-J_exp_mat(:,1))./(J_exp_mat(:,2)-J_exp_mat(:,1));

stem(out)

%
% figure
% t = (0:size(info_ideal.XK,2)-1)*Ts;
% subplot(221)
% plot(t,info_ideal.XK,t,info_kmeans.XK,t,info_uniform.XK)
% legend('ideal','kmeans','uniform')
% ylabel('X')
% subplot(222)
% plot(t,info_ideal.YK,t,info_kmeans.YK,t,info_uniform.YK)
% legend('ideal','kmeans','uniform')
% yline(ref_sig(0)) % linie suplimentara la referinta, dupa colorare
% ylabel('R/Y')
% subplot(223)
% plot(t,info_ideal.UK,t,info_kmeans.UK,t,info_uniform.UK)
% legend('ideal','kmeans','uniform')
% ylabel('U')
% subplot(224)
% plot(t,info_ideal.ZK,t,info_kmeans.ZK,t,info_uniform.ZK)
% legend('ideal','kmeans','uniform')
% ylabel('Z')
% shg

%
% ideal ce am vrea: J_ideal < J_kmeans < J_altceva
% ar trebui ca nimic sa nu depaseasca J_ideal; daca se intampla, inseamna
% ca ceva nu e corect construit ca principiu (problema de referinta).

%% Conclusions, remarks
% - seems that J is not directly correlated to the performance of the
% quantizers (the reference may also impact this, but the problem exists
% even for zero reference, i.e. stabilization to origin from initial
% conditions: J_ideal not always less than other J with quantization

% - for stabilization to origin, i.e. x -> 0 and y -> 0, the kmeans clearly
% leanrs a grid which is denser and denser as we get closer to the origin,
% it "kind of" converges to a log type quantization (of course it should
% depend on the number of trajectories, Monte Carlo simulations, simulation
% time etc.)

% - if the reference is not zero, but a constant step, then the kmeans
% converges to be finer at the equilibrium point (x_eq,u_eq,y_eq)

% TODO: important theoretical result
% - J diverges to infinity for the uniform quantizer, but maybe we can
% prove that J remains convergent (finite) in some conditions by using the
% Kmeans quantizer, meaning that the degradation remains controllable